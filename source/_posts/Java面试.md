---
title: Java面试复习
date: 2021-04-02 16:03:45
tags: [笔记, 面试]
---

# Java面试

小菜鸡也是要找工作的嘛，虽然才研一，基础不好，早早就要开始看咯。反正看了也会忘，忘了就来这再看一遍呗~

---

本文是在网上到处搜集的喔，侵权删。

---

持续更新中~~~

<!-- more -->

<br>

## 1、面试

##### 1.1、介绍简历上的项目，自己主要做了什么？

##### 1.2、项目里给你最大的挑战是什么？遇到了什么问题？如何解决的？从中学到了什么？

- 项目里面会不断出现各种问题，比如数据量过大造成的内存溢出问题，如何让程序运行效率更高，如何证明我们的算法比别人的算法效率高，如何找到新的观点来支撑我们现有的理论，如何向导师和师兄进行沟通完成接下来的工作

##### 1.3、项目架构图能画一下吗？

##### 1.4、觉得项目有哪些地方可以改进完善（比如：可以加一个redis缓存把热点数据缓存起来）

##### 1.5、有没有遇到过内存泄漏的场景？

<br>

## 2、操作系统

#### 2.1、进程与线程的区别？

- 进程是资源分配的最小单位，线程是任务执行的最小单位。
- 进程有自己独立的地址空间，每启动一个进程，系统就会为他分配地址空间，建立数据表来维护代码段、数据栈和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU启动一个线程的花费远比进程要小的多，同时创建一个线程的开销也比进程要小很多。
- 线程之间的通信更方便，同一进程下的线程下线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式**（IPC）**进行。不过如何处理好同步与互斥是编写多线程程序的难点。
- 多线程程序更强壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉不会对另外的进程造成影响，因为进程有自己独立的地址空间。

```
进程间通信（IPC，Inter-Process Communication），指至少两个进程或线程间传送数据或信号的一些技术或方法。
```

#### 2.2、进程间通信

- 尝见的通信方式
  - 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
  - 命名管道FIFO：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
  - 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
  - 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。**共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。**它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
  - 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
  - 套接字Socket：套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
  - 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- 通信类型
  - 共享存储器系统
    - 基于共享数据结构的通信方式（仅适用于传递相对少量的数据，通信效率低，属于低级通信）
    - 基于共享存储区的通信方式
  - 管道通信系统
    - 管道是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件（pipe文件）
      - 管道机制需要提供一下几点的协调能力
        - 互斥，即当一个进程正在对pipe执行读/写操作时，其它进程必须等待
        - 同步，当一个进程将一定数量的数据写入，然后就去睡眠等待，直到读进程将数据取走，再去唤醒。读进程与之类似
        - 确定对方是否存在
  - 消息传递系统
    - 直接通信方式
      - 发送进程利用OS所提供的发送原语直接把消息发给目标进程
    - 间接通信方式
      - 发送和接收进程都通过共享实体（邮箱）的方式进行消息的发送和接收
  - 客户机服务器系统
    - 套接字 – 通信标识型的数据结构是进程通信和网络通信的基本构件
      - 基于文件型的 （当通信进程都在同一台服务器中）其原理类似于管道
      - 基于网络型的（非对称方式通信，发送者需要提供接收者命名。通信双方的进程运行在不同主机环境下被分配了一对套接字，一个属于发送进程，一个属于接收进程）
    - 远程过程调用和远程方法调用

#### 2.3、进程间的主要调度算法有哪些

- 先来先去服务 FCFS

- 时间片轮转法 RR

- 短作业优先 SJF

- 多级反馈队列调度算法

- 优先级调度 PSA

#### 2.4、僵尸进程产生的原因？

- 僵尸进程是指它的父进程没有等待(调用 wait/waitpid)。如果子进程先结束而父进程后结束，即子进程结束后，父进程还在继续运行但是并未调用 wait/waitpid 那子进程就会成为僵尸进程。但如果子进程后结束，即父进程先结束了，但没有调用 wait/waitpid 来等待子进程的结束， 此时子进程还在运行，父进程已经结束。那么并不会产生僵尸进程。应为每个进程结束时， 系统都会扫描当前系统中运行的所有进程，看看有没有哪个进程时刚刚结束的这个进程的子 进程，如果有就有 init 来接管它，成为它的父进程。
- 进程设置僵尸状态的目的是维护子进程的信息，以便父进程在以后某个时间获取。要在当前 进程中生成一个子进程，一般需要调用 fork 这个系统调用，fork 这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，可以通过返回值来判断其 返回点。如果子进程先于父进程退出， 同时父进程又没有调用 wait/waitpid，则该子进程将成为僵尸进程
- 在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是 仍然保留了一些信息（如进程号 pid 退出状态 运行时间等）。这些保留的信息直到进程通过调用 wait/waitpid 时才会释放。这样就导致了一个问题，如果没有调用 wait/waitpid 的话，那 么保留的信息就不会释放。比如进程号就会被一直占用了。但系统所能使用的进程号的有限 的，如果产生大量的僵尸进程，将导致系统没有可用的进程号而导致系统不能创建进程。所 以我们应该避免僵尸进程。

#### 2.5、孤儿进程产生的原因？

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤 儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，管理孤儿进程这个重任就落到了 init 进程身上，因此孤儿进程并 不会有什么危害。

#### 2.6、讲一下虚拟内存。虚拟内存和物理内存的关系是什么？

- 虚拟内存使得应用程序认为它拥有一个连续的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。

- 虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。虚拟内存让每个进程拥有一片连续完整的内存空间。

  

- 局部性原理表现在以下两个方面：
  - 时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。
  - 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。

操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块， 每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都 必须在物理内存中。当程序引用到不在物理内存中的页时，会将缺失的部分从磁盘装入物理内存。

##### 页面置换算法

- OPT 页面置换算法（最佳页面置换算法）：所选择的被换出的页面将是最长时间内不再被访问， 通常可以保证获得最低的缺页率。

- FIFO（First In First Out） 页面置换算法（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。

- LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）：将最近最久未使用的页面换出。需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到 链表表头。这样就能保证链表表尾的页面是最近最久未访问的。力扣-实现LRU

- LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）：该置换算法选择在之前时期使用最少的页面作为淘汰页。

<br>

## 3、Java基础

#### 3.1、创建对象的方式有哪几种？

- new Obj..()

- clone()：使用 Object 类的 clone 方法。

- 反射

  - 调用 public 无参构造器 ，若是没有，则会报异常：

    ```java
    Object o = clazz.newInstance();
    ```

  - 有带参数的构造函数的类，先获取到其构造对象，再通过该构造方法类获取实例：

    ```java
    //获取构造函数类的对象
    Constroctor constroctor = User.class.getConstructor(String.class);
    //  使用构造器对象的newInstance方法初始化对象
    Object obj =  constroctor.newInstance("name");
    ```

- 通过反序列化来创建对象： 实现 Serializable 接口。