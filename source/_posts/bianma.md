---
title: 编码
date: 2021-06-30 20:51:09
tags: 笔记
---

# 原码、反码和补码

## 基础概念和计算方法

1. 原码

   原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

   ```
   [+1]原 = 0000 0001
   [-1]原 = 1000 0001
   ```

   第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

   ```
   [1111 1111 , 0111 1111]==>[-127 , 127]
   ```

2. 反码

   - 正数的反码使其本身
   - 负数的反码是在其原码的基础上，符号位不变，其余各位取反

   ```
   [+1] = [00000001]原 = [00000001]反
   [-1] = [10000001]原 = [11111110]反
   ```

3. 补码

   - 正数的补码是其本身
   - 负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后加一。（在其反码的基础上+1）

   ```
   [+1] = [00000001]原 = [00000001]反 = [00000001]补
   [-1] = [10000001]原 = [11111110]反 = [11111111]补
   ```

   - 八位二进制补码表示的范围是[-128, 127]

     补码中没有+0与-0, 00000000 是 0，10000000是-128.

## 为什么要用原码、反码和补码

正数因为三种编码方式的结果都相同，而负数的原码、反码和补码是完全不同的。

人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. 

但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了**将符号位也参与运算的方法**.

根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

## 进阶

2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1

一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!

补码在反码的基础上+1, 只是相当于增加了膜的值。

## java中的<<、 >>以及>>>

- **<<表示左移，不分正负数，低位补0；**　

- **>>表示右移，如果该数为正，则高位补0，若为负数，则高位补1；**

- **>>>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0**